---
title: "Testing for differential expression along tumor time"
author: "Karsten Bach"
date: '`r Sys.Date()`'
output:
  html_notebook:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: united
    highlight: tango
    code_folding: hide
---
***

```{r, message=FALSE,warning=FALSE}
library(scran)
library(DT)
library(scater)
library(plyr)
library(dplyr)
library(knitr)
library(ggplot2)
library(Rtsne)
library(cowplot)
library(Matrix)
library(gridExtra)
library(pheatmap)
library(irlba)
library(ggrastr)
library(reshape2)
source("functions.R")

dataList <- readRDS("../data/Robjects/ExpressionList_QC.rds")
sfs <- read.csv("../data/Robjects/SizeFactors.csv")
m <- dataList[["counts"]]
pD <- dataList[["phenoData"]]
pD <- left_join(pD,sfs)
fD <- dataList[["featureData"]]
rm(dataList)

anno <- read.csv("../data/Robjects/CellTypes.csv")[,-1]
umap <- read.csv("../data/Robjects/UMAP_all.csv")[,-1]
substructure <- read.csv("../data/Robjects/Substructure.csv")[,-1]
ttime <- read.csv("../data/Robjects/TumorTime.csv")[,-1]
pD <- right_join(pD,anno)
pD <- left_join(pD,umap)
pD <- left_join(pD,substructure)
pD <- left_join(pD,ttime)

cellSums <- as.vector(table(pD$ranktumorTime))

# keepgenes <- fD$uniqnames[fD$KeepForHvg]
m <- m[,pD$barcode]
sce <- SingleCellExperiment(assays=list(counts=m))
sizeFactors(sce) <- pD$sf
sce <- normalize(sce)
m <- logcounts(sce)
rm(sce)
rownames(pD) <- pD$barcode
gc()
```

# Differential expression over time

- This needs further work.
- Lowly expressed genes are messed up in the DE test (higher threshold?)
- Background mRNA correction!

### A simple LM with tumorTime as predictor

```{r, fig.width=7, fig.height=7, warning=FALSE, message=FALSE}
## Remove the tumor sample
pD.sub <- pD[pD$tumorTime!=1,]

pD.sub$cluster.sample <- paste0("Cluster_",pD.sub$CellType,"_TumorTime_",pD.sub$tumorTime)
# remove low cluster.sample combinations
rmv <- names(which(table(pD.sub$cluster.sample) < 10))
pD.sub <- pD.sub[!(pD.sub$cluster.sample %in% rmv),]

library(scater)
# here you want the raw counts
m.raw <- readRDS("../data/Robjects/ExpressionList.rds")[["counts"]]
fD.raw <- readRDS("../data/Robjects/ExpressionList.rds")[["featureData"]]

rownames(m.raw) <- gsub("-",".",uniquifyFeatureNames(fD.raw$id,fD.raw$symbol))

m.raw <- m.raw[,pD.sub$barcode]
summed.full <- sumCountsAcrossCells(m.raw,pD.sub$cluster.sample)

#
out <- list()
for (cl in levels(pD.sub$CellType)) {
    keep <- grep(paste0("^Cluster_", cl), colnames(summed.full))
    if (length(keep)>=5) {
	summed <- summed.full[,keep]
	# dim(summed)
	# head(colnames(summed))

	# remove low lib sizes
	library(edgeR)
	y.exp <- DGEList(summed)
	discarded <- isOutlier(y.exp$samples$lib.size, log=TRUE, type="lower")
	y.exp <- y.exp[,!discarded]

	# remove lowly expressed genes
	keep <- aveLogCPM(y.exp) > aveLogCPM(10, lib.size=mean(y.exp$samples$lib.size))
	keep <- keep & rowSums(cpm(y.exp)>0)>=3 #Also require gene to be expressed in min 3 samples
	y.exp <- y.exp[keep,]
	# summary(keep)

	# normalization
	y.exp <- calcNormFactors(y.exp)
	#         y.exp$samples

	sample.time <- as.numeric(unlist(lapply(strsplit(colnames(y.exp$counts),"_"),function(x) x[4])))
	dsgn <- model.matrix(~sample.time)

	# Dispersion estimation
	y.exp <- estimateDisp(y.exp, dsgn)
	#         summary(y.exp$trended.dispersion)
	#         plotBCV(y.exp)

	# QL dispersion
	fit.exp <- glmQLFit(y.exp, dsgn, robust=TRUE)
	#         summary(fit.exp$var.prior)
	#         summary(fit.exp$df.prior)
	#         plotQLDisp(fit.exp)  

	# DE test
	#         con <- makeContrasts(statusBRCA1 - statusNormal, levels=dsgn)
	res.exp <- glmQLFTest(fit.exp)#, contrast=con)
	top <- topTags(res.exp, n=16876)$table
	out[[cl]] <- top[top$FDR < 0.1,]
    } 
}
lapply(out,head)
```

## Ambient mRNA
- A lot of the DE genes stem from ambient mRNA, see for example `r head(rownames(out[["Fb6"]]))` as DE genes in Fibroblasts.
- I am following Aaron's approach by reading in the raw dataFiles

### Read in raw data
```{r, fig.width=7, fig.height=7, warning=FALSE, message=FALSE}
library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask=FALSE)
sample.id <- unique(pD$SeqID)
sample.paths <- character(length(sample.id))
for (i in seq_along(sample.id)) {
    fname <- sprintf("Sample%s_matrix.mtx", sample.id[i]) 
    sample.paths[i] <- bfcrpath(bfc, file.path("../data/rawData/",fname))
}
```
### Set up ambient mRNA count matrix
```{r}
collected <- vector("list", length(sample.id))
for (i in seq_along(collected)) {
    curmat <- Matrix::readMM(sample.paths[i])
    is.empty <- Matrix::colSums(curmat) < 100
    collected[[i]] <- Matrix::rowSums(curmat[,is.empty])
}
collected <- do.call(cbind, collected)
colnames(collected) <- sample.id
dim(collected)


gene.path <- bfcrpath(bfc, file.path("../data/rawData/","genes.tsv"))
gene.tab <- read.delim(gene.path, header=FALSE, stringsAsFactors=FALSE)
rownames(collected) <- gsub("-",".",uniquifyFeatureNames(gene.tab[,1],gene.tab[,2]))

###  MATCHING ROWNAMES # NOT IDEAL YET, THERE are 35 features in collected with non-zero values that are dropped if I do the following, probably negligble but might want to fix this fuckydifuckfuck
# maaaa <- match(rownames(m.raw), rownames(collected))
# stopifnot(all(!is.na(m))) # sanity check!
comfeats <- intersect(rownames(m.raw),rownames(collected))
collected <- collected[comfeats,]   
m.raw <- m.raw[comfeats,]
summed.full <- sumCountsAcrossCells(m.raw,pD.sub$cluster.sample)

# Collected needs to be summed per biological sample
tb <- table(pD$SeqID,pD$tumorTime)
out <- data.frame(numeric(nrow(collected)))
colnames(out) <- paste0("TumorTime_",colnames(tb)[1])
for (smp in colnames(tb)) {
    tbs <- rownames(tb)[tb[,smp]!=0]
    if(length(dim(collected[,tbs]))==2) {
	expr <- rowSums(collected[,tbs])
    } else {
	expr <- collected[,tbs]
    }
    colname <- paste0("TumorTime_",smp)
    out[,colname] <- expr
}
ambient <- out[,colnames(out)!="TumorTime_1"] # remove tumor 
rownames(ambient) <- rownames(collected)
```

## Repeate the DE analysis

-We combine `summed` with `collected` before creating a `DGEList` object.
```{r}
cl <- "Fb6"
keep <- grep(paste0("^Cluster_", cl), colnames(summed.full))
summed <- summed.full[,keep]

overall <- cbind(summed, ambient)
y.amb <- DGEList(overall)
# y.amb$samples 
#We filter out low-abundance genes and estimate normalization factors as previously described.
# Also only filter on the genes that are low in the actual samples of interest
coi <- colnames(y.amb) %in% colnames(summed)
keep <- rowMeans(cpm(y.amb[,coi],log=T)) > aveLogCPM(20, lib.size=mean(y.amb$samples$lib.size))
keep <- keep & rowSums(cpm(y.amb)>0)>=3 #Also require gene to be expressed in min 3 samples
y.amb <- y.amb[keep,]
# summary(keep)

#norm
y.amb <- calcNormFactors(y.amb)
# y.amb$samples
```

From ATL:
"Here, we use a new design matrix that accounts for the relationship between cluster 13's expression and the ambient pool in the same sample.
The first four coefficients represent the log-expression of the ambient pool in each sample,
while the last two coefficients represent the log-fold change of the summed cell expression profiles over the ambient pool in the KO or WT conditions. "

__At the moment I am defining an early and late tumor group because I don't know how to set up the LM for a continuous__

```{r}
s <- factor(rep(colnames(ambient), 2))
sample.time <- as.numeric(unlist(lapply(strsplit(colnames(y.amb$counts),"_"),function(x) x[4])))
sample.time <- sample.time[!is.na(sample.time)]
new.sample.time <- rep(sample.time, 2) # If cont to be used replace tmpoint in the model with this
isamb <- rep(c("N", "Y"), each=7)
tmpoint <- ifelse(new.sample.time<0.1,"Early","Late")
design.amb <- model.matrix(~0 + s + tmpoint:isamb)

# Get to full rank:
design.amb <- design.amb[,!grepl("isambY", colnames(design.amb))] 

# Syntactically valid colnames:
colnames(design.amb) <- make.names(colnames(design.amb)) 
design.amb


# estimate disp and ql disp
y.amb <- estimateDisp(y.amb, design.amb)
# summary(y.amb$trended.dispersion)
fit.amb <- glmQLFit(y.amb, design.amb, robust=TRUE)    
# summary(fit.amb$var.prior)
# summary(fit.amb$df.prior)

```
Finally, we test for differences between WT and KO.
The key here is to identify genes that have different cell/ambient log-fold changes between conditions.
This corresponds to a non-zero two-way interaction effect between genotype and the cell/ambient factors. 
(Equivalently, the interaction term can be interpreted as the difference in the KO/WT log-fold change computed from the cell profile compared to that from the ambient profiles.)
By doing so, we can mitigate the effect of differences in the ambient pool between conditions.


```{r}
con <- makeContrasts(tmpointLate.isambN - tmpointEarly.isambN, levels=design.amb)
res.amb <- glmQLFTest(fit.amb, contrast=con)
summary(decideTests(res.amb,p.value=0.1))
top <- topTags(res.amb, n=16876)$table
top <- top[top$FDR < 0.1,]
head(top)
```

```{r, fig.width=7, fig.height=7, warning=FALSE, message=FALSE}
overviewPlot <- function(m,pD,gene,
			 dim1="Group.UMAP1",dim2="Group.UMAP2",
			 variable="CellType",bplot=TRUE) {
    require(cowplot)
    require(viridis)
    exps <- data.frame(gene=m[gene,],
			barcode=colnames(m))
    colnames(exps)[1] <- gene
    pD <- left_join(pD,exps)
    p0 <- ggplot(pD, aes_string(x=variable, y=gene, fill=variable)) +
	geom_boxplot() +
	geom_point() +
	theme(legend.position="none",
	      axis.text=element_text(size=7))

    p1 <- ggplot(pD, aes_string(x=dim1, y=dim2, color=gene)) +
	geom_point() +
	theme_void() +
	ggtitle(gene) +
	scale_color_viridis()

    pout <- plot_grid(p1,p0,nrow=1)
    if (bplot) {
	return(p0)
    } else {
	return(p1)
    }
    
}
overviewPlot(m[,pD$CellType=="Fb6"],pD[pD$CellType=="Fb6",],rownames(top)[1],variable="factor(ranktumorTime)")
```
