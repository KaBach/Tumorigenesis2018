---
title: "Tumorigenesis Sanity Check"
author: "Karsten Bach"
date: '`r Sys.Date()`'
output:
  html_notebook:
    toc: true
    toc_depth: 2
    toc_float: true
    theme: journal
    highlight: tango
    code_folding: hide
---
***

- In this document I just have a first look at the data and check consistency with my previous findings, none of this will be part of the analysis

# Data before and after correction
```{r, message=FALSE, fig.width=10, fig.height=5}
library(scran)
library(scater)
library(dplyr)
library(knitr)
library(ggplot2)
library(Rtsne)
library(cowplot)
library(Matrix)
library(viridis)
library(DT)
# source("functions.R")

# Load Data
dataList <- readRDS("../data/combined_Robjects/ExpressionList_QC_norm.rds")
m <- dataList[["counts"]]
pD <- dataList[["phenoData"]]
rownames(pD) <- pD$barcode
fD <- dataList[["featureData"]]
rm(dataList)

ump <- read.csv("../data/combined_Robjects/UMAP_corrected.csv",row.names=1,stringsAsFactor=FALSE)
```

## Outliers prior to correction
- There are some obvious outlier in the UMAP prior to correction
- No association to any particular sample
- Appear to have low values for most QC parameters, however nothing I could threshold on
- I will flag them at this stage and will decide later on whether on not they have to be removed
```{r, message=FALSE}
pD <- pD[ump$barcode,]
pD <- left_join(pD,ump)
p <- ggplot(pD, aes(x=UMAP1Uncor, y=UMAP2Uncor, fill=Batch)) +
    geom_point(pch=21,size=0.9)  +
    scale_fill_brewer(palette="Set1")
p
pD$PreCorrectionOutlier <- ifelse(pD$UMAP2Uncor>25,"Yes","No")
p0 <- ggplot(pD, aes(y=log10(UmiSums), x=PreCorrectionOutlier)) +
	     geom_boxplot()
p1 <- ggplot(pD, aes(y=log10(GenesDetected), x=PreCorrectionOutlier)) +
	     geom_boxplot()
p2 <- ggplot(pD, aes(y=prcntMito, x=PreCorrectionOutlier)) +
	     geom_boxplot()
plot_grid(p0,p1,p2,nrow=1)
```

## Comparison to correction
- For visualization purposes I do remove the outliers
- The data after batch correction looks better, however the different populations appear closer to each other?
```{r, message=FALSE, fig.width=10, fig.height=5}
pD.so <- pD[pD$PreCorrectionOutlier=="No",]
p0 <- ggplot(pD.so, aes(x=UMAP1Uncor, y=UMAP2Uncor, fill=Batch)) +
    geom_point(pch=21,size=0.9)  +
    scale_fill_brewer(palette="Set1")
p1 <- ggplot(pD.so, aes(x=UMAP1, y=UMAP2,fill=Batch)) +
    geom_point(pch=21,size=0.9) +
    scale_fill_brewer(palette="Set1")
plot_grid(p0,p1)

pD.so.sub <- pD.so[pD.so$Condition %in% c("CBLA0","CBLA1","CBLA2"),]
p0 <- ggplot(pD.so.sub, aes(x=UMAP1Uncor, y=UMAP2Uncor, fill=Batch)) +
    geom_point(pch=21,size=0.8)  +
    scale_fill_brewer(palette="Set1") +
    ggtitle("Only CBLA")
p1 <- ggplot(pD.so.sub, aes(x=UMAP1, y=UMAP2,fill=Batch)) +
    geom_point(pch=21,size=0.8) +
    scale_fill_brewer(palette="Set1") +
    ggtitle("Only CBLA")
plot_grid(p0,p1)
```

## Preliminary clustering
```{r, message=FALSE, fig.width=10, fig.height=5, cache=TRUE}
library(igraph)
umapgraph <- readRDS("../data/combined_Robjects/UMAP_graphs.rds")
igr.cor <- umapgraph[["Corrected"]]
igr.uncor <- umapgraph[["Uncorrected"]]
cl.cor <- cluster_walktrap(igr.cor,steps=3)
pD$CorCluster <- as.factor(cl.cor$membership)
cl.uncor <- cluster_walktrap(igr.uncor,steps=3)
pD$UncorCluster <- as.factor(cl.uncor$membership)

pD <- left_join(pD,ump)
pD.so <- pD[pD$PreCorrectionOutlier=="No",]
p0 <- ggplot(pD.so, aes(x=UMAP1Uncor, y=UMAP2Uncor, fill=UncorCluster)) +
    geom_point(pch=21)  
p1 <- ggplot(pD.so, aes(x=UMAP1, y=UMAP2,fill=CorCluster)) +
    geom_point(pch=21) 
plot_grid(p0,p1)

p0 <- group_by(pD, UncorCluster, Batch) %>%
    summarize(n=n()) %>%
    mutate(frac=n/sum(n)) %>%
    ungroup() %>%
    ggplot(., aes(x=UncorCluster,y=frac, fill=Batch)) +
    geom_bar(stat="identity") 

p1 <- group_by(pD, CorCluster, Batch) %>%
    summarize(n=n()) %>%
    mutate(frac=n/sum(n)) %>%
    ungroup() %>%
    ggplot(., aes(x=CorCluster,y=frac, fill=Batch)) +
    geom_bar(stat="identity") 

plot_grid(p0,p1)

pD.sub <- pD[pD$Condition %in% c("CBLA0","CBLA1","CBLA2"),]
p0 <- group_by(pD.sub, UncorCluster, Batch) %>%
    summarize(n=n()) %>%
    mutate(frac=n/sum(n)) %>%
    ungroup() %>%
    ggplot(., aes(x=UncorCluster,y=frac, fill=Batch)) +
    geom_bar(stat="identity") 

p1 <- group_by(pD.sub, CorCluster, Batch) %>%
    summarize(n=n()) %>%
    mutate(frac=n/sum(n)) %>%
    ungroup() %>%
    ggplot(., aes(x=CorCluster,y=frac, fill=Batch)) +
    geom_bar(stat="identity") 

plot_grid(p0,p1)
```

## Comparison to previous cell types
- There is a fairly good overlap with previously identified celltypes
```{r, message=FALSE, fig.width=10, fig.height=5}
celltypes <- read.csv("../data/firstBatch_Robjects/CellTypes.csv",stringsAsFactors=FALSE)
pD <- left_join(pD,celltypes[,c("barcode","CellType","MajorGroups","Groups")])
pD$CellType[is.na(pD$CellType)] <- "Undetermined"
pD$MajorGroups[is.na(pD$MajorGroups)] <- "Undetermined"
pD$Groups[is.na(pD$Groups)] <- "Undetermined"

pD.so <- pD[pD$PreCorrectionOutlier=="No",]
p0 <- ggplot(pD.so, aes(x=UMAP1Uncor, y=UMAP2Uncor, color=MajorGroups)) +
    geom_point(size=1)  +
    scale_color_brewer(palette="Set1")
p1 <- ggplot(pD.so, aes(x=UMAP1, y=UMAP2,color=MajorGroups)) +
    geom_point(size=1) +
    scale_color_brewer(palette="Set1")
plot_grid(p0,p1)

grps <- group_by(filter(pD,MajorGroups!="Undetermined"), CorCluster, Groups) %>%
    summarize(n=n()) %>%
    mutate(frac=n/sum(n)) %>%
    ungroup() %>%
    ggplot(.,aes(x=CorCluster, y=frac, fill=Groups)) +
    geom_bar(stat="identity") 

ctypes <- group_by(filter(pD,MajorGroups!="Undetermined"), CorCluster, CellType ) %>%
    summarize(n=n()) %>%
    mutate(frac=n/sum(n)) %>%
    ungroup() %>%
    ggplot(.,aes(x=CorCluster, y=frac, fill=CellType)) +
    geom_bar(stat="identity") 

grps
ctypes

```

### In more depth

- A better way to visualize this is as confusion matrix between the previous 
  classification and the new one (where I ignore the cells from batch2)
- It is reassuring to see that almost all clusters are dominated by one previous celltype
- Rows with multiple red spots (or none) indicate cell types that have now been split in multiple clusters
- Columns with multiple high values correspond to clusters that now incorporate multiple cell types
- Couple of observations:
    - Vascular epithelial cells are bunched in one cluster, which is useful
    - Some of the fibroblast clusters are collapsed in fewer clusters which is also useful
    - Caf1 is lost?
    - Caf2/3 now in one Cluster 
    - Cluster 2 is a mess
    - mDC no longer a seperate cluster?
    - Dc209 now split in 3
    - __Av is split__
    - This is without merging clusters after DE min 10
    - The pre correction outliers are all in cluster 39 (see below) basophils (Bp)

```{r, message=FALSE, fig.width=8, fig.height=8}
pD.sub <- pD[pD$MajorGroups!="Undetermined",]

conf <- as.matrix(table(pD.sub$CellType,pD.sub$CorCluster))
conf <- t(t(conf)/colSums(conf))
library(pheatmap)
pheatmap(conf,
	 cluster_rows=FALSE,
	 cluster_cols=FALSE)
```

```{r, message=FALSE, fig.width=8, fig.height=8}
table(pD$PreCorrectionOutlier,pD$CorCluster)
```

### Can we still do the pseudotumor time trajectory?
- It's not looking great but also not awful
- the code below if subset to batch 1 reproduces previous result
- with batch 2 the ordering still makes sense but the two CBLAs are a bit funny.. have to check that
- might be an issue of cell type definition as this isn't done properly here
```{r, message=FALSE, fig.width=10, fig.height=5}
m.raw <- readRDS("../data/combined_Robjects/CountMatrix.rds")
conf <- as.matrix(table(pD$Groups,pD$CorCluster))
conf <- t(t(conf)/colSums(conf))
myeloid.clusters <- colnames(conf)[conf["Myeloid",]>0.2]
myeloid.clusters <- myeloid.clusters[!is.na(myeloid.clusters)]
myeloid.cells <- pD$barcode[pD$CorCluster %in% myeloid.clusters]

rownames(pD) <- pD$barcode
pD.sub <- pD[myeloid.cells,]
m.sub <- m.raw[,myeloid.cells]
# m.sub <- m.sub[rowMeans(m.sub)>0.01,]



out <- data.frame(numeric(nrow(m.sub)))
colnames(out) <- levels(factor(pD.sub$Condition))[1]
for (cond in levels(factor(pD.sub$Condition))) {
    expr <- rowMeans(m.sub[,pD.sub$Condition==cond])
    colname <- cond
    out[,colname] <- expr
}
rownames(out) <- rownames(m.sub)
out <- out[rowSums(out)>0,]

library(edgeR)
y <- DGEList(counts=out)
y <- calcNormFactors(y)
out <- cpm(y,log=TRUE)

pcs <- prcomp(t(out))
pca <- data.frame(pcs$x)
pca[,"Condition"] <- colnames(out)
ages <- pD[!duplicated(pD$Condition),c("Condition","Age","Batch")]
pca <- left_join(pca, ages)
rownames(pca) <- pca$Condition

library(ggrepel)
ggplot(pca, aes(x=PC1, y=PC2, color=Age,label=Condition,shape=Batch)) +
    geom_text_repel(size=3) +
    geom_point(size=2)
```
